#!/usr/bin/python

import sys
import time
from utils import *

config = config_get()

packages = "keystone python-mysqldb pwgen"
service = "keystone"

# used to verify joined services are valid openstack components.
# this should reflect the current "core" components of openstack
# and be expanded as we add support for them as a distro
valid_services = {
    "nova": {
        "type": "compute",
        "desc": "Nova Compute Service"
    },
    "ec2": {
        "type": "ec2",
        "desc": "EC2 Compatibility Layer"
    },
    "glance": {
        "type": "image",
        "desc": "Glance Image Service"
    },
    "swift": {
        "type": "storage",
        "desc": "Swift Object Storage Service"
    }
}

def install_hook():
    if config["keystone-release"] != "distro":
        setup_ppa(config["keystone-release"])
    execute("apt-get update", die=True)
    execute("apt-get -y install %s" % packages, die=True, echo=True)
    update_config_block('DEFAULT', public_port=config["service-port"])
    update_config_block('DEFAULT', admin_port=config["admin-port"])

    # Set or generate the keystone.conf admin token.  This can probably go 
    # away soon since the admin tokens will be deprecated in favor of service
    # tenants. http://etherpad.openstack.org/keystone-admin-config
    if config['admin-token'] != "None":
        juju_log("Configuring keystone.conf to use a preconfigured admin"\
                 "token")
        token = config['admin-token']
    else:
        juju_log("Generating an keystone.conf admin token.")
        token = execute('pwgen -c 32 1', die=True)[0]
    update_config_block('DEFAULT', admin_token=token)

    # set all backends to use sql+sqlite, if they are not already by default
    update_config_block('sql',
                        connection='sqlite:////var/lib/keystone/keystone.db')
    update_config_block('identity',
                        driver='keystone.identity.backends.sql.Identity')
    update_config_block('catalog',
                        driver='keystone.catalog.backends.sql.Catalog')
    update_config_block('token',
                        driver='keystone.token.backends.sql.Token')
    update_config_block('ec2',
                        driver='keystone.contrib.ec2.backends.sql.Ec2')
    execute("service keystone stop", echo=True)
    execute("keystone-manage db_sync")
    #NOTE(adam_g): This chown can be removed once packaging switches to sql
    # and does this for us
    execute("chown keystone /var/lib/keystone/ -R")
    execute("service keystone start", echo=True)
    time.sleep(5)
    ensure_initial_admin(config)

def db_joined():
    relation_data = { "database": config["database"],
                      "username": config["database-user"],
                      "hostname": config["hostname"] }
    relation_set(relation_data)

def db_changed():
    relation_data = relation_get(["private-address", "password"])
    if len(relation_data) != 2:
        juju_log("private-address or password not set. Peer not ready, exit 0")
        exit(0)
    update_config_block('sql', connection="mysql://%s:%s@%s/%s" %
                            (config["database-user"],
                             relation_data["password"],
                             relation_data["private-address"],
                             config["database"]))
    execute("service keystone stop", echo=True)
    execute("keystone-manage db_sync", echo=True)
    execute("service keystone start")
    time.sleep(5)
    ensure_initial_admin(config)

def identity_joined():
    """ Do nothing until we get information about requested service """
    pass

def identity_changed():
    """ A service has advertised its API endpoints, create an entry in the 
        service catalog. """
    # TODO(adm_g): Need to add this type of logic back
    #relation_data = relation_get(options)
    #if len(relation_data) != len(options):
    #    juju_log("Missing relation data.  Peer not ready, exit 0")
    #    exit(0)
    def ensure_valid_service(service):
        if service not in valid_services.keys():
            juju_log("WARN: Invalid service requested: '%s'" % service)
            realtion_set({ "admin_token": -1 })
            return

    def add_endpoint(region, service, public_url, admin_url, internal_url):
        desc = valid_services[service]["desc"]
        service_type = valid_services[service]["type"]
        create_service_entry(service, service_type, desc)
        create_endpoint_template(region=region, service=service,
                                 public_url=public_url,
                                 admin_url=admin_url,
                                 internal_url=internal_url)

    settings = relation_get_dict()

    # the minimum settings needed per endpoint
    single = set(['service', 'region', 'public_url', 'admin_url',
                  'internal_url'])
    if single.issubset(settings):
        # other end of relation advertised only one endpoint
        ensure_valid_service(settings['service'])
        add_endpoint(region=settings['region'], service=settings['service'],
                     public_url=settings['public_url'],
                     admin_url=settings['admin_url'],
                     internal_url=settings['internal_url'])
    else:
        # assemble multiple endpoints from relation data. service name
        # should be prepended to setting name, ie:
        #  realtion-set ec2_service=$foo ec2_region=$foo ec2_public_url=$foo
        #  relation-set nova_service=$foo nova_region=$foo nova_public_url=$foo
        # Results in a dict that looks like:
        # { 'ec2': {
        #       'service': $foo
        #       'region': $foo
        #       'public_url': $foo
        #   }
        #   'nova': {
        #       'service': $foo
        #       'region': $foo
        #       'public_url': $foo
        #   }
        # }
        endpoints = {}
        for k,v in settings.iteritems():
            ep = k.split('_')[0]
            x = '_'.join(k.split('_')[1:])
            if ep not in  endpoints:
                endpoints[ep] = {}
            endpoints[ep][x] = v
        for ep in endpoints:
            # weed out any unrelated relation stuff Juju might have added
            # by ensuring each possible endpiont has appropriate fields
            #  ['service', 'region', 'public_url', 'admin_url', 'internal_url']
            if single.issubset(endpoints[ep]):
                ep = endpoints[ep]
                ensure_valid_service(ep['service'])
                add_endpoint(region=ep['region'], service=ep['service'],
                             public_url=ep['public_url'],
                             admin_url=ep['admin_url'],
                             internal_url=ep['internal_url'])

    token = get_admin_token()
    # we return a token, information about our API endpoints
    relation_data = {
        "admin_token": token,
        "service_host": config["hostname"],
        "service_port": config["service-port"],
        "auth_host": config["hostname"],
        "auth_port": config["admin-port"]
    }
    relation_set(relation_data)

def keystone_joined():
    """
    The keystone-service relations exist specifically for horizon.  Instead of
    a token and entry in the service catalog (like other services), it requires
    a token and a role.  It doesn't expose any endpoint that keystone needs to
    care about, thus it relates to this unit via its own service relation.
    """
    pass

def keystone_changed():
    """ Horizon will request a default role, we create it and return a
        token
    """
    options = ["role"]
    relation_data = relation_get(options)
    if len(relation_data) != len(options):
        juju_log("Missing relation data.  Peer not ready, exit 0")
        exit(0)
    # create the requested admin role
    create_role(relation_data["role"],
                config["admin-user"], config['admin-role'])
    token = get_admin_token()
    # Return token and API ports.  Let horizon find our hostname via
    # 'relation-get private-address'
    relation_data = {
        "service_port": config["service-port"],
        "auth_port": config["admin-port"],
        "admin_token": token
    }
    relation_set(relation_data)

hooks = {
    "install": install_hook,
    "shared-db-relation-joined": db_joined,
    "shared-db-relation-changed": db_changed,
    "identity-service-relation-joined": identity_joined,
    "identity-service-relation-changed": identity_changed,
    "keystone-service-relation-joined": keystone_joined,
    "keystone-service-relation-changed": keystone_changed
}

# keystone-hooks gets called by symlink corresponding to the requested relation
# hook.
arg0 = sys.argv[0].split("/").pop()
if arg0 not in hooks.keys():
    error_out("Unsupported hook: %s" % arg0)
hooks[arg0]()
